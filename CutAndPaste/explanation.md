# Cut and Paste

Problem statement can be found [here](https://cses.fi/problemset/task/2072/).

A naive approach to this problem would take O(n) time complexity per each query, which would be O(nm). Since each of these variables can be 2*10^5 = 200000, this would be too slow for competitive programming.

To come up with a faster algorithm, we will use a structure called [Treap](https://en.wikipedia.org/wiki/Treap). Basically, a treap is a tree combined with a heap (that's where the name comes from). It's a binary tree in which we store values inside nodes in some order. The twist is that every node has a *priority* sorted randomly at initialization, and then the nodes are arranged in a way that, if we only look at the priorities, the tree is a heap. Since the priority is sorted at random, estadistically the tree won't end up being too unbalanced, making the queries to the tree O(logn) *average case* time complexity.

This structure comes as an alternative to AVL-trees in competitive programming because, although we trade a O(logn) worst case time complexity by an O(logn) average case complexity, the treaps are quite easy to implement, allowing us to implement the whole structure in a reasonable time during competition. In use cases where we just have to use the standard queries such as insert, search and delete elements in the tree, we can just use a library implementation of an AVL-tree, but in problems like this one sometimes we need to dive inside the structure, make some structural changes, or maybe build the structure from scratch. That's when the advantage of the treaps comes into play.

Overall, the way we construct and operate with treaps is by using two methods: split and merge. Split recieves a treap and a value and returns two treaps: the treap that contains the values below the given parameter, and the treap with the values above the given value. Merge recieves two treaps and returns another treap that contains the nodes of both given treaps respecting their values ordering and priorities.

In this problem, each node will contain a character of the string and, at all times, the order of the characters in the treap will be the order of the string at that moment after doing some queries. The modification we will do to the original structure is that we will use implicit keys. This means that we are going to store the size of each subtree in order to efficiently compute the index of one particular node in the order given by the tree. That way we will be able to perform the operation "split the treap at the first k nodes".

So in this particular treap, the values will not determine the order of the nodes, but the opposite: the order of the nodes will determine the order in which we will return the values (i.e. the characters of the string) at the end of the execution.

With all this machinery, we can easily perform a query in O(logn) average time complexity like so: If we are asked to cut the string between *a* and *b*, we can split the tree at *a*, leaving us with two treaps, say T\_1 and T\_2, where T\_1 contains the first *a* characters and T\_2 the rest. Then, we split T\_2 at *b*, leaving us with another two treaps T\_middle and T\_right, where T\_middle contains the values between *a* and *b* and T\_right contains the last *n-b* values. Lastly, we merge these three treaps in the correct order, which is T\_1 - T\_right - T\_middle (which will be the "paste" part). Split and merge do all the work for us.

There are two last details to talk about this implementation: The methods "evaluate" and "heapify". Evaluate is the method that keeps updated the attribute of each node that stores the size of its subtree. And heapify is used when constructing the treap at the beginning of execution. Since the order is already determined by the starting string, instead of just using the random priorities to determine the distribution of the nodes we initialize a balanced tree, and then rearrange the priorities (heapify) in order to meet the heap condition.
