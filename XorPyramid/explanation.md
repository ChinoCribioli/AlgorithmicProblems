# XorPyramid

The problem statement can be found [here](https://cses.fi/problemset/task/2419/).

The main difficulty of this problem is the size of the pyramid. Computing the whole pyramid naively is quite easy, but each level would be computed in O(n) time. Since we would have to compute n levels, this would be a O(n^2) solution, which is not fast enough since n can be up to 2*10^5 = 200000. So we need to find a more clever strategy.

First, let's just think about the problem only with bits rather than integer values. Let's observe a square denoted as *s*: It can be either 0 or 1, but let's not focus on this. Let's focus in _which squares of the lower levels affect the value of *s*_. For instance, if we look at the level right below, the only squares that affect its value are the ones below (the lower-left and the lower-right ones). This means that, in other words, if we change the value of one of these, the value of *s* will change. We will call these two squares *s\_l* and *s\_r*.

Let's go one level below. How many squares affect the value of *s*? We are tempted to say 3, the three ones below *s\_l* and *s\_r*. However, if we look carefully, the square in the middle (let's denote it as *m*) doesn't affect the value of *s*. You can try that with a piece of paper, but basically the idea is that *m* affects both *s\_l* and *s\_r*, so if we change the value of *m*, the values of *s\_l* and *s\_r* will both change, and then the value of *s* will stay the same (because we are dealing with bits, so changing twice is the same as not changing at all).

With this observation, we can note that a square will affect the value of *s* if and only if exactly 1 of its 2 parents affect the value, where the parents of a square are the two squares right above it. If we color the squares of the pyramid with black if the square affects the value of the top and white if not, we can see a very curious and, for me, familiar pattern. It seems like a sort of [Sierpi≈Ñski triangle](https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle), especially the one we can obtain by [iterating from a square](https://en.wikipedia.org/wiki/File:Sierpinski_triangle_evolution_square.svg). So let's use this pattern to fasten our computation.

Let's observe that, if we consider the top of the pyramid at level 1, all the squares in levels powers of 2 affect the value of the top. So, looking at the squares as bits, we can confidently say that the value of the top is equal to the xor of all the values of squares of level 2^i **for any natural number i**. And then, when thinking of the squares as any positive integer, we can note that every bit of the binary representation of the numbers is totally independent from the others, because the only operation we do is a bitwise xor. So we can conclude that the statement _"the value of the top is equal to the xor of all the values of squares of level 2^i for any natural number i"_ holds true for positive integers.

This property is great, since it gives us a fast way to compute the value of a square by only using the values of the squares of the level 2^i steps below. This will allow us to perform what I'll call "jumps of length 2^i", that is basically computing the squares of level x using the squares of level x+2^i. Then, if we have the squares of level n, we can find the value of level 1 in O(logn) steps, which will give us a O(nlogn) time complexity algorithm. And, even better, the bits of n in binary representation will tell us which jumps to make. For instance, if n = 13 = 8 + 4 + 1, which is 1101 in binary, we will perform a jump of length 8, a jump of length 4, and a jump of length 1 and will obtain the solution calculating only 3 intermediate levels.
